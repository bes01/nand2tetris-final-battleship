class AIShips{
	
	field RandomUtil random;
	field Int xStart, yStart, dimension;
	field Array grid; // i - x, j - y


	constructor AIShips new(RandomUtil randomInstance, Int x, Int y, Int shipDimension){
		let random = randomInstance;
		let xStart = x;
		let yStart = y;
		let dimension = shipDimension;
		let grid = Array.new(dimension);

		do resetBoard(true);

		return this;
	}

	method void receiveOpponentShot(int i, int j){
		var Array tempArray;
		var Int cellType;

		let tempArray = grid[i];
		let cellType = tempArray[j]; 

		if(cellType = 0){
			do toggleShipPart(i, j, 3);
		}
		if(cellType = 1){
			do toggleShipPart(i, j, 2);
		}
		
		do checkIfSank(i, j);
		
		return;
	}

	// TODO: implement vertical and horizontal check
	method void checkIfSank(int i, int j){
		var Int start, end, direction;
		var Boolean isSank;

		let direction = checkShipDirection(i, j);
		do Output.printInt(direction);
		// horizontal
		if(direction = 1){

		}
		
		// vertical
		if(direction = 2){
			
		}

		// point
		if(direction = 3){
			do Sys.wait(500);
			do toggleShipPart(i, j, 1);
		}

		return;
	}

	// 0 - empty cell, 1 - horizontal, 2 - vertical, 3 - point
	method Int checkShipDirection(int i, int j){
		var Int x, y;
		var Array tempArray;
		var boolean isPoint;

		let isPoint = false;
		let tempArray = grid[i];
		if(tempArray[j] = 2){
			let isPoint = true;
		}

		// check horizontal
		if(isPoint & validateBoundaries(i + 1, j)){
			let tempArray = grid[i + 1];
			if((tempArray[j] = 2) | (tempArray[j] = 1)){
				return 1;
			}
		}
		if(isPoint & validateBoundaries(i - 1, j)){
			let tempArray = grid[i - 1];
			if((tempArray[j] = 2) | (tempArray[j] = 1)){
				return 1;
			}
		}

		// check vertical
		if(isPoint & validateBoundaries(i, j - 1)){
			let tempArray = grid[i];
			if((tempArray[j - 1] = 2) | (tempArray[j - 1] = 1)){
				return 2;
			}
		}
		if(isPoint & validateBoundaries(i, j + 1)){
			let tempArray = grid[i];
			if((tempArray[j + 1] = 2) | (tempArray[j + 1] = 1)){
				return 2;
			}
		}
		
		// isPoint
		if(isPoint){
			return 3;
		}

		// it's point
		return 0;
	}

	// modes: 0 - clear, 1 - X, 2 - !, 3 - #, 4 - mark matrix
	method void toggleShipPart(Int i, Int j, Int mode){
		var Boolean black;
		var Array tempArray;
		var Int tempInt;

		let tempArray = grid[i];

		if(mode = 0){ // clear
			let tempArray[j] = 0;
			let i = xStart + (i * dimension);
			let j = yStart + (j * dimension);
			do Screen.setColor(false);
			do Screen.drawRectangle(i + 2, j + 2, i + dimension - 2, j + dimension - 2);
		}

		if(mode = 1){ // X - sank
			do toggleShipPart(i, j, 0);  // TODO: remove afterwards
			let tempArray[j] = -1;
			let i = xStart + (i * dimension);
			let j = yStart + (j * dimension);

			// drawing !
			do Screen.setColor(true);
			do Screen.drawLine(i + 2, j + 3, i + dimension - 2, j + dimension - 2);
			do Screen.drawLine(i + 2, j + 2, i + dimension - 3, j + dimension - 2);
			do Screen.drawLine(i + 2, j + dimension - 3, i + dimension - 3, j + 2);
			do Screen.drawLine(i + 2, j + dimension - 2, i + dimension - 2, j + 2);
			// do Screen.drawRectangle(i + 9, j + 15, i + 10, j + 17);
		}

		if(mode = 2){ // ! - partially sank
			do toggleShipPart(i, j, 0);  // TODO: remove afterwards
			let tempArray[j] = 2;
			let i = xStart + (i * dimension);
			let j = yStart + (j * dimension);

			// drawing !
			do Screen.setColor(true);
			do Screen.drawRectangle(i + 9, j + 2, i + 10, j + 13);
			do Screen.drawRectangle(i + 9, j + 15, i + 10, j + 17);
		}

		if(mode = 3){ // # - missed shots
			let tempArray[j] = 3;
			let i = xStart + (i * dimension);
			let j = yStart + (j * dimension);
			let tempInt = ((dimension / 3) + 1);

			// drawing #
			do Screen.drawLine(i + 1, j + tempInt, i + 18, j + tempInt);
			do Screen.drawLine(i + 1, j + (2 * tempInt), i + 18, j + (2 * tempInt));
			do Screen.drawLine(i + tempInt, j + 1, i + tempInt, j + 18);
			do Screen.drawLine(i + (2 * tempInt), j + 1, i + (2 * tempInt), j + 18);
		}

		if(mode = 4){ // mark matrix / put ship
			let tempArray[j] = 1;
			let i = xStart + (i * dimension);
			let j = yStart + (j * dimension);
			do Screen.setColor(true); //TODO: remove coloring
			do Screen.drawRectangle(i + 2, j + 2, i + dimension - 2, j + dimension - 2);
		}

		return;
	}

	// find place randomly for ship
	method void placeShipSomewhere(Int shipLength){
		var Int start, end;
		var Int i;
		var Int j;
		var Boolean direction; // false - vertical, true - horizontal
		var Boolean endLoop;
		var Int k;

		
		while(true){ // keep while until success
			let i = random.nextInt(10);
			let j = random.nextInt(10);

			if(validateCoordinate(i, j)){
				if(shipLength = 1){
					do toggleShipPart(i, j, 4);
					return;
				}

				let direction = random.nextBoolean(); // TODO: make better random
				if(direction = 0){ // first we try to go up, then down
					let end = j;
					let endLoop = false;
					while((j > -1) & ~endLoop){ // find space up
						if(~validateCoordinate(i, j)){
							let endLoop = true;
							let start = j + 1;
						}
						let j = j - 1;
					}
					let j = end; // restore j;
					let endLoop = false;
					while((j < (dimension - 1)) & ~endLoop){
						if(~validateCoordinate(i, j)){
							let endLoop = true;
							let end = j - 1;
						}
						let j = j + 1;
					}

					if((((end - start) + 1) > shipLength) | (((end - start) + 1) = shipLength)){
						let k = 0;
						while(k < shipLength){
							do toggleShipPart(i, start + k, 4);
							let k = k + 1;
						}
						return;
					}									
				}
				if(direction = 1){ // first we try to go left, then right
					let end = i;
					let endLoop = false;
					while((i > -1) & ~endLoop){ // find left up
						if(~validateCoordinate(i, j)){
							let endLoop = true;
							let start = i + 1;
						}
						let i = i - 1;
					}
					let i = end; // restore i;
					let endLoop = false;
					while((i < (dimension - 1)) & ~endLoop){
						if(~validateCoordinate(i, j)){
							let endLoop = true;
							let end = i - 1;
						}
						let i = i + 1;
					}
					if((((end - start) + 1) > shipLength) | (((end - start) + 1) = shipLength)){
						let k = 0;
						
						while(k < shipLength){
							do toggleShipPart(start + k, j, 4);
							let k = k + 1;
						}
						return;
					}
				}
			}
		}

		return;
	}

	// validates that no adjacent ship presents
	method Boolean validateCoordinate(Int i, Int j){
		var Int x, y;
		var Array tempArray;

		let x = -1;
		while(x < 2){
			let y = -1;
			while(y < 2){
				if(validateBoundaries(i + x, j + y)){
					let tempArray = grid[i + (x)];
					if(tempArray[j + (y)]){
						return false;
					}
				}
				let y = y + 1;
			}
			let x = x + 1;
		}

		return true;
	}

	method boolean validateBoundaries(Int i, Int j){
		return (i > -1) & (i < 10) & (j > -1) & (j < 10); 
	}

	method void resetBoard(Boolean firstTime){
		var Int i, j;
		var Array tempArray;

		let i = 0;
		while(i < 10){
			let j = 0;
			if(firstTime){
				let tempArray = Array.new(10);
				let grid[i] = tempArray;
			}
			if(~firstTime){
				let tempArray = grid[i];				
			}
			while(j < 10){
				if(tempArray[j]){
					do toggleShipPart(i, j, 0);
				}
				let tempArray[j] = 0;
				let j = j + 1;
			}
			let i = i + 1;
		}

		// randomize ship locations
		do placeShipSomewhere(5);
		do placeShipSomewhere(4);
		do placeShipSomewhere(3);
		do placeShipSomewhere(2);
		do placeShipSomewhere(2);
		do placeShipSomewhere(1);
		do placeShipSomewhere(1);

		return;
	}

}